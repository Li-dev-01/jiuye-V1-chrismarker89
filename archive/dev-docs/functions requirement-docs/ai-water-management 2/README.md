# AIæ°´æºä¸æ°´ç®¡ç®¡ç†åŠŸèƒ½å…‹éš†æ–‡æ¡£

## ğŸ“‹ æ¦‚è¿°

AIæ°´æºä¸æ°´ç®¡ç®¡ç†æ˜¯ä¸€ä¸ªæ™ºèƒ½åŒ–çš„AIæœåŠ¡ç®¡ç†ç³»ç»Ÿï¼Œé‡‡ç”¨"æ°´å‚"éšå–»æ¥ç®¡ç†å¤šä¸ªAIæä¾›å•†ã€‚ç³»ç»Ÿæä¾›ç»Ÿä¸€çš„AIæœåŠ¡åˆ†é…ã€è´Ÿè½½å‡è¡¡ã€æ•…éšœè½¬ç§»ã€æˆæœ¬æ§åˆ¶å’Œæ€§èƒ½ç›‘æ§åŠŸèƒ½ï¼Œç¡®ä¿å„ä¸ªä¸šåŠ¡æ¨¡å—èƒ½å¤Ÿç¨³å®šã€é«˜æ•ˆã€ç»æµåœ°ä½¿ç”¨AIæœåŠ¡ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### ğŸ­ æ°´å‚æ¶æ„
- **AIæ°´æº**ï¼šå„ä¸ªAIæä¾›å•†ï¼ˆOpenAIã€Grokã€Geminiç­‰ï¼‰
- **æ°´ç®¡ç½‘ç»œ**ï¼šæœåŠ¡ç½‘å…³å’Œè·¯ç”±ç³»ç»Ÿ
- **ç”¨æ°´ç»ˆç«¯**ï¼šå„ä¸ªåŠŸèƒ½æ¨¡å—ï¼ˆæ•°æ®ç”Ÿæˆã€å†…å®¹å®¡æ ¸ã€å­¦ä¹ ä¼˜åŒ–ç­‰ï¼‰
- **æ°´å‚åˆ†é…**ï¼šæ™ºèƒ½åˆ†é…ç­–ç•¥ï¼Œæ ¹æ®è´¨é‡ã€æˆæœ¬ã€æ€§èƒ½è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ°´æº

### ğŸ”„ æ™ºèƒ½åˆ†é…ç­–ç•¥
- **è´¨é‡ä¼˜å…ˆ**ï¼šä¼˜å…ˆé€‰æ‹©å“åº”è´¨é‡æœ€é«˜çš„AIæœåŠ¡
- **æˆæœ¬ä¼˜å…ˆ**ï¼šä¼˜å…ˆé€‰æ‹©æˆæœ¬æœ€ä½çš„AIæœåŠ¡
- **å¹³è¡¡æ¨¡å¼**ï¼šåœ¨è´¨é‡å’Œæˆæœ¬ä¹‹é—´å¯»æ‰¾æœ€ä½³å¹³è¡¡ç‚¹
- **æ•…éšœè½¬ç§»**ï¼šä¸»è¦æœåŠ¡ä¸å¯ç”¨æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å¤‡ç”¨æœåŠ¡

## ğŸ“ æ–‡ä»¶ç»“æ„

```
ai-water-management/
â”œâ”€â”€ README.md                          # æœ¬æ–‡æ¡£
â”œâ”€â”€ components/                        # ç»„ä»¶æ–‡ä»¶
â”‚   â”œâ”€â”€ AIWaterManagementPanel.html    # ä¸»ç®¡ç†é¢æ¿
â”‚   â”œâ”€â”€ AIWaterManagementPanel.css     # æ ·å¼æ–‡ä»¶
â”‚   â”œâ”€â”€ AIWaterManagementPanel.js      # äº¤äº’é€»è¾‘
â”‚   â”œâ”€â”€ WaterSourceMonitor.html        # æ°´æºç›‘æ§ç»„ä»¶
â”‚   â””â”€â”€ TerminalStatusDisplay.js       # ç»ˆç«¯çŠ¶æ€æ˜¾ç¤º
â”œâ”€â”€ services/                          # æœåŠ¡æ–‡ä»¶
â”‚   â”œâ”€â”€ waterSourceService.js          # æ°´æºç®¡ç†æœåŠ¡
â”‚   â”œâ”€â”€ pipelineNetworkService.js      # æ°´ç®¡ç½‘ç»œæœåŠ¡
â”‚   â”œâ”€â”€ loadBalancerService.js         # è´Ÿè½½å‡è¡¡æœåŠ¡
â”‚   â””â”€â”€ costControlService.js          # æˆæœ¬æ§åˆ¶æœåŠ¡
â”œâ”€â”€ config/                           # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ water-sources.json            # æ°´æºé…ç½®
â”‚   â”œâ”€â”€ pipeline-config.json          # æ°´ç®¡é…ç½®
â”‚   â”œâ”€â”€ allocation-strategy.json      # åˆ†é…ç­–ç•¥é…ç½®
â”‚   â””â”€â”€ cost-control.json             # æˆæœ¬æ§åˆ¶é…ç½®
â”œâ”€â”€ utils/                            # å·¥å…·æ–‡ä»¶
â”‚   â”œâ”€â”€ healthChecker.js              # å¥åº·æ£€æŸ¥å™¨
â”‚   â”œâ”€â”€ performanceMonitor.js         # æ€§èƒ½ç›‘æ§å™¨
â”‚   â””â”€â”€ failoverManager.js            # æ•…éšœè½¬ç§»ç®¡ç†å™¨
â”œâ”€â”€ examples/                         # ä½¿ç”¨ç¤ºä¾‹
â”‚   â”œâ”€â”€ basic-integration.html        # åŸºç¡€é›†æˆç¤ºä¾‹
â”‚   â”œâ”€â”€ advanced-config.html          # é«˜çº§é…ç½®ç¤ºä¾‹
â”‚   â””â”€â”€ monitoring-dashboard.html     # ç›‘æ§ä»ªè¡¨æ¿ç¤ºä¾‹
â””â”€â”€ test.html                         # åŠŸèƒ½æµ‹è¯•é¡µé¢
```

## ğŸ¤– AIæ°´æºé…ç½®

### æ”¯æŒçš„AIæä¾›å•†
```json
{
  "waterSources": {
    "openai": {
      "id": "openai",
      "name": "OpenAI GPT-4",
      "type": "primary",
      "status": "active",
      "config": {
        "apiKey": "sk-proj-...",
        "endpoint": "https://api.openai.com/v1/chat/completions",
        "model": "gpt-4",
        "thinkingModel": "gpt-4-turbo",
        "maxConcurrent": 10,
        "rateLimit": 60,
        "costPerToken": 0.000030
      },
      "health": {
        "lastCheck": "2024-01-20T10:30:00Z",
        "responseTime": 500,
        "successRate": 98.5,
        "errorCount": 0,
        "uptime": 99.9
      },
      "usage": {
        "requestsToday": 150,
        "tokensUsed": 75000,
        "costToday": 2.45,
        "lastUsed": "2024-01-20T10:25:00Z"
      }
    },
    "grok": {
      "id": "grok",
      "name": "Grok AI",
      "type": "backup",
      "status": "inactive",
      "config": {
        "apiKey": "grok-...",
        "endpoint": "https://api.x.ai/v1/chat/completions",
        "model": "grok-beta",
        "maxConcurrent": 5,
        "rateLimit": 30,
        "costPerToken": 0.000020
      },
      "health": {
        "lastCheck": "2024-01-20T10:30:00Z",
        "responseTime": 0,
        "successRate": 0,
        "errorCount": 5,
        "uptime": 0
      },
      "usage": {
        "requestsToday": 0,
        "tokensUsed": 0,
        "costToday": 0,
        "lastUsed": "2024-01-19T15:30:00Z"
      }
    },
    "gemini": {
      "id": "gemini",
      "name": "Google Gemini",
      "type": "secondary",
      "status": "inactive",
      "config": {
        "apiKey": "AIza...",
        "endpoint": "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent",
        "model": "gemini-pro",
        "maxConcurrent": 8,
        "rateLimit": 40,
        "costPerToken": 0.000025
      },
      "health": {
        "lastCheck": "2024-01-20T10:30:00Z",
        "responseTime": 0,
        "successRate": 0,
        "errorCount": 0,
        "uptime": 0
      },
      "usage": {
        "requestsToday": 0,
        "tokensUsed": 0,
        "costToday": 0,
        "lastUsed": "never"
      }
    }
  }
}
```

## ğŸš¿ æ°´ç®¡ç½‘ç»œé…ç½®

### ç»ˆç«¯åˆ†é…ç­–ç•¥
```json
{
  "terminalAllocations": {
    "data_generation": {
      "terminalId": "data_generation",
      "terminalName": "æ•°æ®ç”Ÿæˆä¸­å¿ƒ",
      "terminalType": "generation",
      "primarySource": "openai",
      "backupSources": ["grok", "gemini"],
      "qualityRequirement": "high",
      "costPriority": "quality_first",
      "maxCostPerRequest": 0.05,
      "enabled": true,
      "allocation": {
        "strategy": "quality_first",
        "fallbackChain": ["openai", "grok", "gemini"],
        "healthCheckInterval": 300,
        "maxRetries": 3,
        "timeoutSeconds": 30
      }
    },
    "content_review": {
      "terminalId": "content_review",
      "terminalName": "å†…å®¹å®¡æ ¸ç³»ç»Ÿ",
      "terminalType": "review",
      "primarySource": "openai",
      "backupSources": ["gemini"],
      "qualityRequirement": "high",
      "costPriority": "balanced",
      "maxCostPerRequest": 0.02,
      "enabled": true,
      "allocation": {
        "strategy": "balanced",
        "fallbackChain": ["openai", "gemini"],
        "healthCheckInterval": 180,
        "maxRetries": 2,
        "timeoutSeconds": 20
      }
    },
    "ai_learning": {
      "terminalId": "ai_learning",
      "terminalName": "AIå­¦ä¹ ä¼˜åŒ–",
      "terminalType": "learning",
      "primarySource": "openai",
      "backupSources": ["gemini"],
      "qualityRequirement": "medium",
      "costPriority": "cost_first",
      "maxCostPerRequest": 0.01,
      "enabled": true,
      "allocation": {
        "strategy": "cost_first",
        "fallbackChain": ["gemini", "openai"],
        "healthCheckInterval": 600,
        "maxRetries": 1,
        "timeoutSeconds": 15
      }
    }
  }
}
```

## ğŸ“Š ç³»ç»Ÿé…ç½®

### è´Ÿè½½å‡è¡¡é…ç½®
```json
{
  "systemConfig": {
    "globalEnabled": true,
    "defaultProvider": "openai",
    "failoverEnabled": true,
    "loadBalanceMode": "percentage",
    "providerPercentages": {
      "openai": 100,
      "grok": 0,
      "gemini": 0
    },
    "healthCheckInterval": 300,
    "maxRetries": 3,
    "timeoutSeconds": 30,
    "batchSize": 10,
    "circuitBreaker": {
      "enabled": true,
      "failureThreshold": 5,
      "recoveryTimeout": 60000,
      "halfOpenMaxCalls": 3
    },
    "rateLimiting": {
      "enabled": true,
      "globalLimit": 1000,
      "perProviderLimit": 500,
      "windowMs": 60000
    }
  }
}
```

### æˆæœ¬æ§åˆ¶é…ç½®
```json
{
  "costControl": {
    "dailyBudget": 50.00,
    "monthlyBudget": 1500.00,
    "alertThresholds": {
      "daily": 40.00,
      "monthly": 1200.00
    },
    "costOptimization": {
      "enabled": true,
      "autoSwitchToLowerCost": true,
      "costThresholdMultiplier": 1.5,
      "qualityMinimumThreshold": 0.8
    },
    "billing": {
      "currency": "USD",
      "trackingEnabled": true,
      "reportingInterval": "daily",
      "costBreakdownByTerminal": true
    }
  }
}
```

## ğŸš€ å¿«é€Ÿä½¿ç”¨

### 1. åŸºç¡€é›†æˆ
```html
<!DOCTYPE html>
<html>
<head>
    <title>AIæ°´æºç®¡ç†</title>
    <link rel="stylesheet" href="components/AIWaterManagementPanel.css">
</head>
<body>
    <div id="ai-water-management-container"></div>
    
    <script src="services/waterSourceService.js"></script>
    <script src="services/loadBalancerService.js"></script>
    <script src="utils/healthChecker.js"></script>
    <script src="components/AIWaterManagementPanel.js"></script>
</body>
</html>
```

### 2. åˆå§‹åŒ–æ°´æºç®¡ç†
```javascript
// åˆ›å»ºAIæ°´æºç®¡ç†å®ä¾‹
const waterManagement = new AIWaterManagementPanel({
    container: '#ai-water-management-container',
    config: {
        autoHealthCheck: true,
        healthCheckInterval: 300000, // 5åˆ†é’Ÿ
        enableCostControl: true,
        enableFailover: true
    },
    onWaterSourceChange: (sourceId, status) => {
        console.log(`æ°´æº ${sourceId} çŠ¶æ€å˜æ›´:`, status);
    },
    onCostAlert: (alert) => {
        console.log('æˆæœ¬é¢„è­¦:', alert);
    },
    onFailover: (from, to) => {
        console.log(`æ•…éšœè½¬ç§»: ${from} -> ${to}`);
    }
});
```

### 3. æ°´æºç®¡ç†ç¤ºä¾‹
```javascript
// æ·»åŠ æ–°çš„AIæ°´æº
async function addWaterSource() {
    const sourceConfig = {
        id: 'claude',
        name: 'Anthropic Claude',
        type: 'secondary',
        config: {
            apiKey: 'claude-api-key',
            endpoint: 'https://api.anthropic.com/v1/messages',
            model: 'claude-3-sonnet',
            maxConcurrent: 5,
            rateLimit: 25,
            costPerToken: 0.000015
        }
    };
    
    try {
        const result = await WaterSourceService.addSource(sourceConfig);
        console.log('æ°´æºæ·»åŠ æˆåŠŸ:', result);
    } catch (error) {
        console.error('æ°´æºæ·»åŠ å¤±è´¥:', error);
    }
}

// æµ‹è¯•æ°´æºè¿æ¥
async function testWaterSource(sourceId) {
    try {
        const result = await WaterSourceService.testConnection(sourceId);
        console.log(`æ°´æº ${sourceId} æµ‹è¯•ç»“æœ:`, result);
        
        if (result.success) {
            console.log(`âœ… è¿æ¥æˆåŠŸï¼Œå“åº”æ—¶é—´: ${result.responseTime}ms`);
        } else {
            console.log(`âŒ è¿æ¥å¤±è´¥: ${result.error}`);
        }
    } catch (error) {
        console.error('æµ‹è¯•å¤±è´¥:', error);
    }
}

// è·å–æœ€ä¼˜æ°´æº
async function getBestWaterSource(terminalType, requirements) {
    try {
        const result = await LoadBalancerService.getBestSource({
            terminalType,
            qualityRequirement: requirements.quality || 'medium',
            costPriority: requirements.costPriority || 'balanced',
            maxCostPerRequest: requirements.maxCost || 0.03
        });
        
        console.log('æ¨èæ°´æº:', result);
        return result;
    } catch (error) {
        console.error('è·å–æœ€ä¼˜æ°´æºå¤±è´¥:', error);
        return null;
    }
}
```

### 4. ç»ˆç«¯çŠ¶æ€ç›‘æ§ç¤ºä¾‹
```javascript
// åˆ›å»ºç»ˆç«¯çŠ¶æ€æ˜¾ç¤ºç»„ä»¶
const terminalStatus = new TerminalStatusDisplay({
    terminalType: 'generation',
    terminalName: 'æ•°æ®ç”Ÿæˆä¸­å¿ƒ',
    container: '#terminal-status',
    showDetails: true,
    refreshInterval: 30000 // 30ç§’åˆ·æ–°
});

// ç›‘å¬çŠ¶æ€å˜åŒ–
terminalStatus.onStatusChange = (status) => {
    console.log('ç»ˆç«¯çŠ¶æ€æ›´æ–°:', status);
    
    // æ›´æ–°UIæ˜¾ç¤º
    updateTerminalUI(status);
};

// æ‰‹åŠ¨åˆ·æ–°çŠ¶æ€
async function refreshTerminalStatus() {
    try {
        await terminalStatus.refresh();
        console.log('ç»ˆç«¯çŠ¶æ€å·²åˆ·æ–°');
    } catch (error) {
        console.error('åˆ·æ–°å¤±è´¥:', error);
    }
}
```

## ğŸ”§ é«˜çº§åŠŸèƒ½

### 1. æ™ºèƒ½æ•…éšœè½¬ç§»
```javascript
// é…ç½®æ•…éšœè½¬ç§»ç®¡ç†å™¨
const failoverManager = new FailoverManager({
    enabled: true,
    healthCheckInterval: 60000, // 1åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    failureThreshold: 3, // è¿ç»­3æ¬¡å¤±è´¥è§¦å‘è½¬ç§»
    recoveryCheckInterval: 300000, // 5åˆ†é’Ÿæ£€æŸ¥æ¢å¤
    
    onFailover: (event) => {
        console.log('æ•…éšœè½¬ç§»äº‹ä»¶:', event);
        // å‘é€å‘Šè­¦é€šçŸ¥
        sendAlert(`AIæœåŠ¡æ•…éšœè½¬ç§»: ${event.from} -> ${event.to}`);
    },
    
    onRecovery: (event) => {
        console.log('æœåŠ¡æ¢å¤äº‹ä»¶:', event);
        // å‘é€æ¢å¤é€šçŸ¥
        sendAlert(`AIæœåŠ¡å·²æ¢å¤: ${event.sourceId}`);
    }
});

// æ‰‹åŠ¨è§¦å‘æ•…éšœè½¬ç§»
async function manualFailover(fromSource, toSource) {
    try {
        const result = await failoverManager.executeFailover(fromSource, toSource);
        console.log('æ‰‹åŠ¨æ•…éšœè½¬ç§»å®Œæˆ:', result);
    } catch (error) {
        console.error('æ•…éšœè½¬ç§»å¤±è´¥:', error);
    }
}
```

### 2. æˆæœ¬æ§åˆ¶å’Œä¼˜åŒ–
```javascript
// æˆæœ¬æ§åˆ¶æœåŠ¡
const costControl = new CostControlService({
    dailyBudget: 50.00,
    monthlyBudget: 1500.00,
    alertThresholds: {
        daily: 40.00,
        monthly: 1200.00
    },
    
    onBudgetAlert: (alert) => {
        console.log('é¢„ç®—é¢„è­¦:', alert);
        
        if (alert.severity === 'critical') {
            // è‡ªåŠ¨åˆ‡æ¢åˆ°ä½æˆæœ¬æ¨¡å¼
            switchToCostOptimizedMode();
        }
    },
    
    onCostOptimization: (optimization) => {
        console.log('æˆæœ¬ä¼˜åŒ–å»ºè®®:', optimization);
    }
});

// è·å–æˆæœ¬åˆ†ææŠ¥å‘Š
async function getCostAnalysis() {
    try {
        const analysis = await costControl.getAnalysis({
            period: 'last_7_days',
            groupBy: 'terminal',
            includeProjections: true
        });
        
        console.log('æˆæœ¬åˆ†æ:', analysis);
        return analysis;
    } catch (error) {
        console.error('è·å–æˆæœ¬åˆ†æå¤±è´¥:', error);
        return null;
    }
}

// åˆ‡æ¢åˆ°æˆæœ¬ä¼˜åŒ–æ¨¡å¼
async function switchToCostOptimizedMode() {
    try {
        const result = await LoadBalancerService.updateGlobalConfig({
            loadBalanceMode: 'cost_optimized',
            providerPercentages: {
                'openai': 20,
                'grok': 0,
                'gemini': 80 // å‡è®¾Geminiæˆæœ¬æ›´ä½
            }
        });
        
        console.log('å·²åˆ‡æ¢åˆ°æˆæœ¬ä¼˜åŒ–æ¨¡å¼:', result);
    } catch (error) {
        console.error('åˆ‡æ¢å¤±è´¥:', error);
    }
}
```

### 3. æ€§èƒ½ç›‘æ§å’Œåˆ†æ
```javascript
// æ€§èƒ½ç›‘æ§å™¨
const performanceMonitor = new PerformanceMonitor({
    metricsInterval: 60000, // 1åˆ†é’Ÿæ”¶é›†ä¸€æ¬¡æŒ‡æ ‡
    retentionDays: 30,
    
    onPerformanceAlert: (alert) => {
        console.log('æ€§èƒ½å‘Šè­¦:', alert);
        
        if (alert.type === 'high_latency') {
            // è‡ªåŠ¨è°ƒæ•´è´Ÿè½½å‡è¡¡
            adjustLoadBalancing(alert);
        }
    }
});

// è·å–æ€§èƒ½æŠ¥å‘Š
async function getPerformanceReport() {
    try {
        const report = await performanceMonitor.generateReport({
            period: 'last_24_hours',
            includeMetrics: ['responseTime', 'successRate', 'throughput', 'errorRate'],
            groupBy: 'source'
        });
        
        console.log('æ€§èƒ½æŠ¥å‘Š:', report);
        return report;
    } catch (error) {
        console.error('è·å–æ€§èƒ½æŠ¥å‘Šå¤±è´¥:', error);
        return null;
    }
}

// æ€§èƒ½ä¼˜åŒ–å»ºè®®
async function getOptimizationSuggestions() {
    try {
        const suggestions = await performanceMonitor.getOptimizationSuggestions();
        
        suggestions.forEach(suggestion => {
            console.log(`ä¼˜åŒ–å»ºè®®: ${suggestion.title}`);
            console.log(`æè¿°: ${suggestion.description}`);
            console.log(`é¢„æœŸæ”¶ç›Š: ${suggestion.expectedImprovement}`);
        });
        
        return suggestions;
    } catch (error) {
        console.error('è·å–ä¼˜åŒ–å»ºè®®å¤±è´¥:', error);
        return [];
    }
}
```

## ğŸ“ˆ ç›‘æ§å’Œå‘Šè­¦

### å¥åº·æ£€æŸ¥é…ç½®
```javascript
// å¥åº·æ£€æŸ¥å™¨é…ç½®
const healthChecker = new HealthChecker({
    checkInterval: 300000, // 5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    timeout: 10000, // 10ç§’è¶…æ—¶
    retryAttempts: 3,
    retryDelay: 5000,
    
    checks: [
        {
            name: 'api_connectivity',
            description: 'APIè¿æ¥æ€§æ£€æŸ¥',
            critical: true
        },
        {
            name: 'response_time',
            description: 'å“åº”æ—¶é—´æ£€æŸ¥',
            threshold: 5000, // 5ç§’é˜ˆå€¼
            critical: false
        },
        {
            name: 'error_rate',
            description: 'é”™è¯¯ç‡æ£€æŸ¥',
            threshold: 0.05, // 5%é”™è¯¯ç‡é˜ˆå€¼
            critical: true
        },
        {
            name: 'rate_limit',
            description: 'é€Ÿç‡é™åˆ¶æ£€æŸ¥',
            critical: false
        }
    ],
    
    onHealthChange: (sourceId, health) => {
        console.log(`æ°´æº ${sourceId} å¥åº·çŠ¶æ€å˜æ›´:`, health);
        
        if (health.status === 'unhealthy') {
            // è§¦å‘å‘Šè­¦
            sendHealthAlert(sourceId, health);
        }
    }
});

// æ‰§è¡Œå…¨é¢å¥åº·æ£€æŸ¥
async function performFullHealthCheck() {
    try {
        const results = await healthChecker.checkAllSources();
        
        console.log('å…¨é¢å¥åº·æ£€æŸ¥ç»“æœ:');
        results.forEach(result => {
            const status = result.healthy ? 'âœ…' : 'âŒ';
            console.log(`${status} ${result.sourceId}: ${result.summary}`);
            
            if (result.issues.length > 0) {
                console.log('  é—®é¢˜:', result.issues);
            }
        });
        
        return results;
    } catch (error) {
        console.error('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
        return [];
    }
}
```

### å‘Šè­¦ç³»ç»Ÿ
```javascript
// å‘Šè­¦ç®¡ç†å™¨
const alertManager = new AlertManager({
    channels: ['console', 'webhook', 'email'],
    webhookUrl: 'https://your-webhook-url.com/alerts',
    emailConfig: {
        smtp: 'smtp.example.com',
        from: 'alerts@example.com',
        to: ['admin@example.com']
    },
    
    rules: [
        {
            name: 'water_source_down',
            condition: 'source.status === "error"',
            severity: 'critical',
            message: 'AIæ°´æº {{source.name}} å·²ç¦»çº¿'
        },
        {
            name: 'high_cost',
            condition: 'cost.daily > budget.daily * 0.8',
            severity: 'warning',
            message: 'ä»Šæ—¥æˆæœ¬å·²è¾¾é¢„ç®—çš„80%'
        },
        {
            name: 'high_latency',
            condition: 'metrics.responseTime > 5000',
            severity: 'warning',
            message: 'AIæœåŠ¡å“åº”æ—¶é—´è¿‡é•¿: {{metrics.responseTime}}ms'
        }
    ]
});

// å‘é€è‡ªå®šä¹‰å‘Šè­¦
function sendCustomAlert(title, message, severity = 'info') {
    alertManager.send({
        title,
        message,
        severity,
        timestamp: new Date().toISOString(),
        source: 'ai_water_management'
    });
}
```

## ğŸ§ª æµ‹è¯•å’Œè°ƒè¯•

### æµ‹è¯•å·¥å…·
```javascript
// AIæ°´æºç®¡ç†æµ‹è¯•å¥—ä»¶
class AIWaterManagementTests {
    static async runAllTests() {
        console.log('ğŸ§ª å¼€å§‹è¿è¡ŒAIæ°´æºç®¡ç†æµ‹è¯•...');
        
        const tests = [
            this.testWaterSourceConnection,
            this.testLoadBalancing,
            this.testFailover,
            this.testCostControl,
            this.testHealthCheck
        ];
        
        const results = [];
        for (const test of tests) {
            try {
                const result = await test();
                results.push({ name: test.name, success: true, result });
                console.log(`âœ… ${test.name}: é€šè¿‡`);
            } catch (error) {
                results.push({ name: test.name, success: false, error: error.message });
                console.log(`âŒ ${test.name}: å¤±è´¥ - ${error.message}`);
            }
        }
        
        return results;
    }
    
    static async testWaterSourceConnection() {
        // æµ‹è¯•æ‰€æœ‰æ°´æºè¿æ¥
        const sources = await WaterSourceService.getAllSources();
        const results = [];
        
        for (const source of sources) {
            const testResult = await WaterSourceService.testConnection(source.id);
            results.push({
                sourceId: source.id,
                success: testResult.success,
                responseTime: testResult.responseTime
            });
        }
        
        return results;
    }
    
    static async testLoadBalancing() {
        // æµ‹è¯•è´Ÿè½½å‡è¡¡ç®—æ³•
        const requests = [];
        for (let i = 0; i < 100; i++) {
            const source = await LoadBalancerService.getBestSource({
                terminalType: 'generation',
                qualityRequirement: 'medium'
            });
            requests.push(source.id);
        }
        
        // ç»Ÿè®¡åˆ†é…ç»“æœ
        const distribution = {};
        requests.forEach(sourceId => {
            distribution[sourceId] = (distribution[sourceId] || 0) + 1;
        });
        
        return distribution;
    }
    
    static async testFailover() {
        // æµ‹è¯•æ•…éšœè½¬ç§»æœºåˆ¶
        const primarySource = 'openai';
        const backupSource = 'gemini';
        
        // æ¨¡æ‹Ÿä¸»è¦æœåŠ¡æ•…éšœ
        await WaterSourceService.simulateFailure(primarySource);
        
        // æ£€æŸ¥æ˜¯å¦è‡ªåŠ¨åˆ‡æ¢åˆ°å¤‡ç”¨æœåŠ¡
        const currentSource = await LoadBalancerService.getCurrentSource('generation');
        
        if (currentSource.id === backupSource) {
            // æ¢å¤ä¸»è¦æœåŠ¡
            await WaterSourceService.restoreService(primarySource);
            return { success: true, failedOver: true };
        } else {
            throw new Error('æ•…éšœè½¬ç§»æœªæ­£å¸¸å·¥ä½œ');
        }
    }
    
    static async testCostControl() {
        // æµ‹è¯•æˆæœ¬æ§åˆ¶åŠŸèƒ½
        const costData = await CostControlService.getCurrentCosts();
        const budget = await CostControlService.getBudgetLimits();
        
        return {
            dailyCost: costData.daily,
            dailyBudget: budget.daily,
            utilizationRate: (costData.daily / budget.daily) * 100,
            withinBudget: costData.daily <= budget.daily
        };
    }
    
    static async testHealthCheck() {
        // æµ‹è¯•å¥åº·æ£€æŸ¥åŠŸèƒ½
        const healthResults = await HealthChecker.checkAllSources();
        
        return {
            totalSources: healthResults.length,
            healthySources: healthResults.filter(r => r.healthy).length,
            unhealthySources: healthResults.filter(r => !r.healthy).length,
            overallHealth: healthResults.every(r => r.healthy)
        };
    }
}
```

## ğŸ”§ æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### 1. æ°´æºè¿æ¥å¤±è´¥
```javascript
// æ£€æŸ¥APIå¯†é’¥å’Œç«¯ç‚¹é…ç½®
const testResult = await WaterSourceService.testConnection('openai');
if (!testResult.success) {
    console.log('è¿æ¥å¤±è´¥åŸå› :', testResult.error);
    // æ£€æŸ¥ç½‘ç»œè¿æ¥ã€APIå¯†é’¥æœ‰æ•ˆæ€§ã€ç«¯ç‚¹URLæ­£ç¡®æ€§
}
```

#### 2. è´Ÿè½½å‡è¡¡ä¸å·¥ä½œ
```javascript
// æ£€æŸ¥è´Ÿè½½å‡è¡¡é…ç½®
const config = await LoadBalancerService.getConfig();
console.log('å½“å‰é…ç½®:', config);

// é‡ç½®è´Ÿè½½å‡è¡¡å™¨
await LoadBalancerService.reset();
```

#### 3. æˆæœ¬è¶…å‡ºé¢„ç®—
```javascript
// å¯ç”¨æˆæœ¬æ§åˆ¶
await CostControlService.enableBudgetControl({
    dailyLimit: 30.00,
    autoSwitchToLowerCost: true
});

// æŸ¥çœ‹æˆæœ¬åˆ†æ
const analysis = await CostControlService.getAnalysis();
console.log('æˆæœ¬åˆ†æ:', analysis);
```

#### 4. æ•…éšœè½¬ç§»ä¸åŠæ—¶
```javascript
// è°ƒæ•´æ•…éšœæ£€æµ‹å‚æ•°
await FailoverManager.updateConfig({
    healthCheckInterval: 60000, // 1åˆ†é’Ÿæ£€æŸ¥
    failureThreshold: 2, // 2æ¬¡å¤±è´¥å³è½¬ç§»
    recoveryTimeout: 120000 // 2åˆ†é’Ÿåæ£€æŸ¥æ¢å¤
});
```

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **åˆç†è®¾ç½®å¥åº·æ£€æŸ¥é—´éš”**ï¼šè¿‡äºé¢‘ç¹ä¼šå¢åŠ å¼€é”€ï¼Œè¿‡äºç¨€ç–ä¼šå»¶è¿Ÿæ•…éšœå‘ç°
2. **ä¼˜åŒ–æ‰¹æ¬¡å¤§å°**ï¼šæ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´APIè°ƒç”¨çš„æ‰¹æ¬¡å¤§å°
3. **å¯ç”¨ç¼“å­˜**ï¼šå¯¹äºé‡å¤è¯·æ±‚å¯ç”¨å“åº”ç¼“å­˜
4. **ç›‘æ§èµ„æºä½¿ç”¨**ï¼šå®šæœŸæ£€æŸ¥å†…å­˜å’ŒCPUä½¿ç”¨æƒ…å†µ

## ğŸ“Š ç›‘æ§æŒ‡æ ‡

### å…³é”®æ€§èƒ½æŒ‡æ ‡ (KPI)
- **å¯ç”¨æ€§**: ç›®æ ‡ 99.9%
- **å“åº”æ—¶é—´**: ç›®æ ‡ < 2ç§’
- **é”™è¯¯ç‡**: ç›®æ ‡ < 1%
- **æˆæœ¬æ•ˆç‡**: æ¯è¯·æ±‚æˆæœ¬ < $0.05

### ç›‘æ§å‘Šè­¦è§„åˆ™
```javascript
const alertRules = {
    highErrorRate: {
        condition: 'errorRate > 5%',
        action: 'switchToBackupSource'
    },
    highLatency: {
        condition: 'responseTime > 5000ms',
        action: 'enableLoadBalancing'
    },
    budgetExceeded: {
        condition: 'dailyCost > dailyBudget * 0.9',
        action: 'switchToCostOptimizedMode'
    }
};
```

## ğŸ” å®‰å…¨æœ€ä½³å®è·µ

### APIå¯†é’¥ç®¡ç†
- ä½¿ç”¨ç¯å¢ƒå˜é‡å­˜å‚¨APIå¯†é’¥
- å®šæœŸè½®æ¢APIå¯†é’¥
- é™åˆ¶APIå¯†é’¥æƒé™èŒƒå›´
- ç›‘æ§APIå¯†é’¥ä½¿ç”¨æƒ…å†µ

### è®¿é—®æ§åˆ¶
- å®æ–½åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ (RBAC)
- è®°å½•æ‰€æœ‰ç®¡ç†æ“ä½œæ—¥å¿—
- å®šæœŸå®¡è®¡è®¿é—®æƒé™
- ä½¿ç”¨HTTPSåŠ å¯†æ‰€æœ‰é€šä¿¡

### æ•°æ®ä¿æŠ¤
- åŠ å¯†æ•æ„Ÿé…ç½®ä¿¡æ¯
- å®æ–½æ•°æ®è„±æ•ç­–ç•¥
- å®šæœŸå¤‡ä»½é…ç½®æ•°æ®
- éµå¾ªæ•°æ®ä¿æŠ¤æ³•è§„

## ğŸ“ˆ æ‰©å±•å’Œé›†æˆ

### æ·»åŠ æ–°çš„AIæä¾›å•†
```javascript
// 1. å®šä¹‰æä¾›å•†é…ç½®
const newProviderConfig = {
    id: 'new_provider',
    name: 'New AI Provider',
    endpoint: 'https://api.newprovider.com/v1/chat',
    authType: 'bearer', // æˆ– 'api_key'
    models: ['model-1', 'model-2'],
    pricing: {
        inputTokens: 0.000020,
        outputTokens: 0.000040
    }
};

// 2. æ³¨å†Œæä¾›å•†
await WaterSourceService.registerProvider(newProviderConfig);

// 3. æ·»åŠ é€‚é…å™¨
class NewProviderAdapter extends BaseAdapter {
    async makeRequest(prompt, options) {
        // å®ç°ç‰¹å®šçš„APIè°ƒç”¨é€»è¾‘
    }

    parseResponse(response) {
        // è§£æå“åº”æ ¼å¼
    }
}

// 4. æ³¨å†Œé€‚é…å™¨
WaterSourceService.registerAdapter('new_provider', NewProviderAdapter);
```

### é›†æˆå¤–éƒ¨ç›‘æ§ç³»ç»Ÿ
```javascript
// PrometheusæŒ‡æ ‡å¯¼å‡º
const prometheusMetrics = {
    aiWaterSourceRequests: new prometheus.Counter({
        name: 'ai_water_source_requests_total',
        help: 'Total number of requests to AI water sources',
        labelNames: ['source_id', 'status']
    }),

    aiWaterSourceLatency: new prometheus.Histogram({
        name: 'ai_water_source_latency_seconds',
        help: 'Latency of AI water source requests',
        labelNames: ['source_id']
    })
};

// é›†æˆåˆ°æ€§èƒ½ç›‘æ§å™¨
performanceMonitor.onMetric = (metric) => {
    if (metric.type === 'request') {
        prometheusMetrics.aiWaterSourceRequests
            .labels(metric.sourceId, metric.status)
            .inc();

        prometheusMetrics.aiWaterSourceLatency
            .labels(metric.sourceId)
            .observe(metric.duration / 1000);
    }
};
```

## ğŸ“š APIå‚è€ƒ

### WaterSourceService API
```javascript
// è·å–æ‰€æœ‰æ°´æº
const sources = await WaterSourceService.getAllSources();

// æ·»åŠ æ°´æº
const result = await WaterSourceService.addSource(config);

// æµ‹è¯•è¿æ¥
const testResult = await WaterSourceService.testConnection(sourceId);

// æ›´æ–°æ°´æºé…ç½®
await WaterSourceService.updateSource(sourceId, newConfig);

// åˆ é™¤æ°´æº
await WaterSourceService.removeSource(sourceId);

// è·å–æ°´æºç»Ÿè®¡
const stats = await WaterSourceService.getSourceStats(sourceId);
```

### LoadBalancerService API
```javascript
// è·å–æœ€ä½³æ°´æº
const bestSource = await LoadBalancerService.getBestSource(requirements);

// æ›´æ–°å…¨å±€ç­–ç•¥
await LoadBalancerService.updateGlobalStrategy(strategy);

// è·å–è´Ÿè½½åˆ†å¸ƒ
const distribution = await LoadBalancerService.getLoadDistribution();

// é‡ç½®è´Ÿè½½å‡è¡¡å™¨
await LoadBalancerService.reset();
```

### CostControlService API
```javascript
// è·å–æˆæœ¬åˆ†æ
const analysis = await CostControlService.getAnalysis(period);

// è®¾ç½®é¢„ç®—é™åˆ¶
await CostControlService.setBudgetLimits(limits);

// è·å–ä¼˜åŒ–å»ºè®®
const suggestions = await CostControlService.getOptimizationSuggestions();

// å¯ç”¨æˆæœ¬æ§åˆ¶
await CostControlService.enableBudgetControl(config);
```

## ğŸ¯ é¡¹ç›®å®ŒæˆçŠ¶æ€

### âœ… å·²å®ŒæˆåŠŸèƒ½

#### æ ¸å¿ƒç»„ä»¶
- [x] **AIWaterManagementPanel** - ä¸»ç®¡ç†é¢æ¿ (HTML/CSS/JS)
- [x] **WaterSourceService** - æ°´æºç®¡ç†æœåŠ¡
- [x] **LoadBalancerService** - è´Ÿè½½å‡è¡¡æœåŠ¡
- [x] **CostControlService** - æˆæœ¬æ§åˆ¶æœåŠ¡
- [x] **HealthChecker** - å¥åº·æ£€æŸ¥å™¨
- [x] **PerformanceMonitor** - æ€§èƒ½ç›‘æ§å™¨
- [x] **FailoverManager** - æ•…éšœè½¬ç§»ç®¡ç†å™¨

#### é…ç½®æ–‡ä»¶
- [x] **water-sources.json** - å®Œæ•´çš„æ°´æºé…ç½®æ–‡ä»¶
- [x] **pipeline-config.json** - æ°´ç®¡ç½‘ç»œé…ç½®
- [x] **allocation-strategy.json** - åˆ†é…ç­–ç•¥é…ç½®
- [x] **cost-control.json** - æˆæœ¬æ§åˆ¶é…ç½®

#### ç¤ºä¾‹å’Œæµ‹è¯•
- [x] **test.html** - åŠŸèƒ½æµ‹è¯•é¡µé¢
- [x] **basic-integration.html** - åŸºç¡€é›†æˆç¤ºä¾‹
- [x] **advanced-config.html** - é«˜çº§é…ç½®ç¤ºä¾‹
- [x] **monitoring-dashboard.html** - ç›‘æ§ä»ªè¡¨æ¿ç¤ºä¾‹

#### æ ¸å¿ƒåŠŸèƒ½ç‰¹æ€§
- [x] å¤šAIæä¾›å•†æ”¯æŒ (OpenAI, Grok, Gemini, Claude)
- [x] æ™ºèƒ½è´Ÿè½½å‡è¡¡ (è´¨é‡ä¼˜å…ˆã€æˆæœ¬ä¼˜å…ˆã€å¹³è¡¡æ¨¡å¼)
- [x] è‡ªåŠ¨æ•…éšœè½¬ç§»å’Œæ¢å¤
- [x] å®æ—¶å¥åº·ç›‘æ§
- [x] æˆæœ¬è·Ÿè¸ªå’Œé¢„ç®—æ§åˆ¶
- [x] æ€§èƒ½æŒ‡æ ‡ç›‘æ§
- [x] ç†”æ–­å™¨æ¨¡å¼
- [x] å¯è§†åŒ–ç®¡ç†ç•Œé¢
- [x] è°ƒè¯•å’Œæµ‹è¯•å·¥å…·

### ğŸš€ å¿«é€Ÿå¯åŠ¨

1. **å…‹éš†é¡¹ç›®**
```bash
git clone <repository-url>
cd function-login/ai-water-management
```

2. **æ‰“å¼€æµ‹è¯•é¡µé¢**
```bash
# ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨æ‰“å¼€ test.html
python -m http.server 8000
# æˆ–ä½¿ç”¨ Node.js
npx serve .
```

3. **è®¿é—®ç®¡ç†ç•Œé¢**
- æµ‹è¯•é¡µé¢: `http://localhost:8000/test.html`
- åŸºç¡€ç¤ºä¾‹: `http://localhost:8000/examples/basic-integration.html`
- ä¸»ç®¡ç†é¢æ¿: `http://localhost:8000/components/AIWaterManagementPanel.html`

### ğŸ“‹ ä½¿ç”¨æ£€æŸ¥æ¸…å•

#### éƒ¨ç½²å‰æ£€æŸ¥
- [ ] é…ç½®APIå¯†é’¥ (åœ¨ `config/water-sources.json` ä¸­)
- [ ] è®¾ç½®é¢„ç®—é™åˆ¶ (åœ¨ `config/cost-control.json` ä¸­)
- [ ] è°ƒæ•´å¥åº·æ£€æŸ¥é—´éš”
- [ ] é…ç½®å‘Šè­¦é€šçŸ¥æ–¹å¼
- [ ] æµ‹è¯•æ‰€æœ‰æ°´æºè¿æ¥

#### è¿è¡Œæ—¶ç›‘æ§
- [ ] ç›‘æ§ç³»ç»Ÿå¥åº·åº¦
- [ ] æ£€æŸ¥æˆæœ¬ä½¿ç”¨æƒ…å†µ
- [ ] è§‚å¯Ÿè´Ÿè½½åˆ†å¸ƒ
- [ ] å…³æ³¨æ•…éšœè½¬ç§»äº‹ä»¶
- [ ] å®šæœŸæŸ¥çœ‹æ€§èƒ½æŠ¥å‘Š

### ğŸ”§ è‡ªå®šä¹‰é…ç½®

#### æ·»åŠ æ–°çš„AIæä¾›å•†
1. åœ¨ `config/water-sources.json` ä¸­æ·»åŠ é…ç½®
2. åœ¨ `WaterSourceService` ä¸­æ³¨å†Œé€‚é…å™¨
3. æ›´æ–°è´Ÿè½½å‡è¡¡ç­–ç•¥
4. æµ‹è¯•è¿æ¥å’ŒåŠŸèƒ½

#### è°ƒæ•´åˆ†é…ç­–ç•¥
1. ä¿®æ”¹ `config/allocation-strategy.json`
2. æ›´æ–°ç»ˆç«¯åˆ†é…è§„åˆ™
3. æµ‹è¯•ç­–ç•¥æ•ˆæœ
4. ç›‘æ§æ€§èƒ½å˜åŒ–

#### è‡ªå®šä¹‰å‘Šè­¦è§„åˆ™
1. é…ç½®å‘Šè­¦é˜ˆå€¼
2. è®¾ç½®é€šçŸ¥æ¸ é“
3. å®šä¹‰å‘Šè­¦çº§åˆ«
4. æµ‹è¯•å‘Šè­¦è§¦å‘

### ğŸ› å¸¸è§é—®é¢˜è§£å†³

#### APIè¿æ¥é—®é¢˜
```javascript
// æ£€æŸ¥APIå¯†é’¥é…ç½®
const testResult = await WaterSourceService.testConnection('openai');
console.log('è¿æ¥æµ‹è¯•:', testResult);
```

#### è´Ÿè½½å‡è¡¡å¼‚å¸¸
```javascript
// é‡ç½®è´Ÿè½½å‡è¡¡å™¨
await LoadBalancerService.reset();
console.log('è´Ÿè½½å‡è¡¡å™¨å·²é‡ç½®');
```

#### æˆæœ¬è¶…å‡ºé¢„ç®—
```javascript
// å¯ç”¨è‡ªåŠ¨æˆæœ¬æ§åˆ¶
await CostControlService.enableBudgetControl({
    autoSwitchToLowerCost: true,
    dailyLimit: 30.00
});
```

### ğŸ“Š æ€§èƒ½åŸºå‡†

#### ç³»ç»ŸæŒ‡æ ‡ç›®æ ‡
- **å¯ç”¨æ€§**: > 99.9%
- **å“åº”æ—¶é—´**: < 2ç§’
- **é”™è¯¯ç‡**: < 1%
- **æˆæœ¬æ•ˆç‡**: < $0.05/è¯·æ±‚

#### è´Ÿè½½èƒ½åŠ›
- **å¹¶å‘è¯·æ±‚**: 50+
- **æ¯åˆ†é’Ÿè¯·æ±‚**: 1000+
- **æ”¯æŒæ°´æº**: 10+
- **ç»ˆç«¯æ•°é‡**: æ— é™åˆ¶

### ğŸ”® æœªæ¥è§„åˆ’

#### çŸ­æœŸç›®æ ‡ (1-2ä¸ªæœˆ)
- [ ] æ·»åŠ æ›´å¤šAIæä¾›å•†æ”¯æŒ
- [ ] å®ç°è¯·æ±‚ç¼“å­˜æœºåˆ¶
- [ ] å¢å¼ºç›‘æ§ä»ªè¡¨æ¿
- [ ] ä¼˜åŒ–æˆæœ¬ç®—æ³•

#### ä¸­æœŸç›®æ ‡ (3-6ä¸ªæœˆ)
- [ ] æœºå™¨å­¦ä¹ ä¼˜åŒ–åˆ†é…
- [ ] å¤šåœ°åŸŸéƒ¨ç½²æ”¯æŒ
- [ ] é«˜çº§åˆ†ææŠ¥å‘Š
- [ ] APIç½‘å…³é›†æˆ

#### é•¿æœŸç›®æ ‡ (6-12ä¸ªæœˆ)
- [ ] äº‘åŸç”Ÿéƒ¨ç½²
- [ ] å¾®æœåŠ¡æ¶æ„
- [ ] ä¼ä¸šçº§å®‰å…¨
- [ ] ç¬¬ä¸‰æ–¹é›†æˆç”Ÿæ€

### ğŸ¤ è´¡çŒ®æŒ‡å—

#### å¼€å‘ç¯å¢ƒè®¾ç½®
1. Fork é¡¹ç›®ä»“åº“
2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
3. è¿›è¡Œå¼€å‘å’Œæµ‹è¯•
4. æäº¤ Pull Request

#### ä»£ç è§„èŒƒ
- ä½¿ç”¨ ES6+ è¯­æ³•
- éµå¾ª JSDoc æ³¨é‡Šè§„èŒƒ
- ä¿æŒä»£ç ç®€æ´å¯è¯»
- ç¼–å†™å•å…ƒæµ‹è¯•

#### æäº¤è§„èŒƒ
- feat: æ–°åŠŸèƒ½
- fix: ä¿®å¤é—®é¢˜
- docs: æ–‡æ¡£æ›´æ–°
- style: ä»£ç æ ¼å¼
- refactor: é‡æ„
- test: æµ‹è¯•ç›¸å…³

### ğŸ“ æ”¯æŒä¸åé¦ˆ

#### è·å–å¸®åŠ©
- æŸ¥çœ‹æ–‡æ¡£å’Œç¤ºä¾‹
- è¿è¡Œæµ‹è¯•é¡µé¢è¯Šæ–­
- æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°
- æŸ¥çœ‹å®æ—¶æ—¥å¿—

#### åé¦ˆæ¸ é“
- GitHub Issues
- æŠ€æœ¯è®¨è®ºåŒº
- é‚®ä»¶æ”¯æŒ
- ç¤¾åŒºè®ºå›

### ğŸ“ˆ ç›‘æ§å’Œç»´æŠ¤

#### æ—¥å¸¸ç»´æŠ¤
- å®šæœŸæ£€æŸ¥ç³»ç»Ÿå¥åº·
- ç›‘æ§æˆæœ¬ä½¿ç”¨æƒ…å†µ
- æ›´æ–°APIå¯†é’¥
- å¤‡ä»½é…ç½®æ–‡ä»¶

#### æ€§èƒ½ä¼˜åŒ–
- åˆ†æå“åº”æ—¶é—´è¶‹åŠ¿
- ä¼˜åŒ–è´Ÿè½½åˆ†é…ç­–ç•¥
- è°ƒæ•´å¥åº·æ£€æŸ¥é¢‘ç‡
- æ¸…ç†å†å²æ•°æ®

#### å®‰å…¨æ£€æŸ¥
- å®šæœŸè½®æ¢APIå¯†é’¥
- æ£€æŸ¥è®¿é—®æ—¥å¿—
- æ›´æ–°å®‰å…¨é…ç½®
- ç›‘æ§å¼‚å¸¸æ´»åŠ¨

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®éµå¾ª MIT è®¸å¯è¯ã€‚

---

**ğŸ‰ æ­å–œï¼AIæ°´æºä¸æ°´ç®¡ç®¡ç†ç³»ç»Ÿå·²å®Œæ•´å®ç°ï¼**

è¿™æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€æ¶æ„æ¸…æ™°ã€æ˜“äºæ‰©å±•çš„AIæœåŠ¡ç®¡ç†ç³»ç»Ÿã€‚é€šè¿‡"æ°´å‚"éšå–»ï¼Œå°†å¤æ‚çš„AIæœåŠ¡ç®¡ç†å˜å¾—ç›´è§‚æ˜“æ‡‚ã€‚ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„ç®¡ç†ç•Œé¢ã€å¼ºå¤§çš„ç›‘æ§åŠŸèƒ½ã€æ™ºèƒ½çš„è´Ÿè½½å‡è¡¡å’Œæˆæœ¬æ§åˆ¶èƒ½åŠ›ã€‚

ç«‹å³å¼€å§‹ä½¿ç”¨ï¼Œä½“éªŒæ™ºèƒ½åŒ–çš„AIæœåŠ¡ç®¡ç†ï¼ğŸš€
