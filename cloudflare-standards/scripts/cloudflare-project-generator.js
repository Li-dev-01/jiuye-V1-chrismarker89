#!/usr/bin/env node

/**
 * Cloudflare È°πÁõÆÊ®°ÊùøÁîüÊàêÂô®
 * Âü∫‰∫é jiuye-V1 È°πÁõÆÁªèÈ™åÂà∂‰Ωú
 * 
 * ‰ΩøÁî®ÊñπÊ≥ï:
 * node scripts/cloudflare-project-generator.js my-project
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class CloudflareProjectGenerator {
  constructor(projectName) {
    this.projectName = projectName;
    this.projectPath = path.join(process.cwd(), projectName);
  }

  async generate() {
    console.log(`üöÄ ÂàõÂª∫ Cloudflare È°πÁõÆ: ${this.projectName}`);
    
    // ÂàõÂª∫È°πÁõÆÁõÆÂΩïÁªìÊûÑ
    this.createDirectoryStructure();
    
    // ÁîüÊàêÈÖçÁΩÆÊñá‰ª∂
    this.generateConfigFiles();
    
    // ÁîüÊàê‰ª£Á†ÅÊ®°Êùø
    this.generateCodeTemplates();
    
    // ÁîüÊàêÊñáÊ°£
    this.generateDocumentation();
    
    // ÂàùÂßãÂåñ Git
    this.initializeGit();
    
    console.log(`‚úÖ È°πÁõÆÂàõÂª∫ÂÆåÊàêÔºÅ`);
    console.log(`\nüìã ‰∏ã‰∏ÄÊ≠•Êìç‰Ωú:`);
    console.log(`cd ${this.projectName}`);
    console.log(`pnpm install`);
    console.log(`pnpm dev`);
  }

  createDirectoryStructure() {
    console.log('üìÅ ÂàõÂª∫ÁõÆÂΩïÁªìÊûÑ...');
    
    const directories = [
      '',
      'frontend',
      'frontend/src',
      'frontend/src/components',
      'frontend/src/pages',
      'frontend/src/services',
      'frontend/src/stores',
      'frontend/src/types',
      'frontend/src/utils',
      'frontend/public',
      'backend',
      'backend/src',
      'backend/src/routes',
      'backend/src/middleware',
      'backend/src/services',
      'backend/src/types',
      'backend/src/utils',
      'database',
      'database/schemas',
      'database/migrations',
      'database/test-data',
      'docs',
      'scripts'
    ];

    directories.forEach(dir => {
      const fullPath = path.join(this.projectPath, dir);
      if (!fs.existsSync(fullPath)) {
        fs.mkdirSync(fullPath, { recursive: true });
      }
    });
  }

  generateConfigFiles() {
    console.log('‚öôÔ∏è ÁîüÊàêÈÖçÁΩÆÊñá‰ª∂...');

    // Ê†πÁõÆÂΩï package.json
    const rootPackageJson = {
      name: this.projectName,
      version: "1.0.0",
      description: `${this.projectName} - Cloudflare Âπ≥Âè∞È°πÁõÆ`,
      private: true,
      type: "module",
      packageManager: "pnpm@10.8.0",
      engines: {
        node: ">=18.0.0",
        pnpm: ">=8.0.0"
      },
      scripts: {
        dev: "concurrently \"pnpm dev:frontend\" \"pnpm dev:backend\"",
        "dev:frontend": "pnpm --filter frontend dev",
        "dev:backend": "pnpm --filter backend dev",
        build: "pnpm --filter frontend build && pnpm --filter backend build",
        "build:frontend": "pnpm --filter frontend build",
        "build:backend": "pnpm --filter backend build",
        test: "pnpm --filter frontend test && pnpm --filter backend test",
        lint: "pnpm --filter frontend lint && pnpm --filter backend lint",
        "lint:fix": "pnpm --filter frontend lint:fix && pnpm --filter backend lint:fix",
        "type-check": "pnpm --filter frontend type-check && pnpm --filter backend type-check",
        deploy: "pnpm build && pnpm deploy:frontend && pnpm deploy:backend",
        "deploy:frontend": "pnpm --filter frontend deploy",
        "deploy:backend": "pnpm --filter backend deploy"
      },
      workspaces: ["frontend", "backend"],
      devDependencies: {
        "@types/node": "^22.0.0",
        "concurrently": "^8.2.2",
        "typescript": "^5.5.4"
      },
      keywords: [
        "cloudflare-workers",
        "cloudflare-pages",
        "typescript",
        "react"
      ],
      author: "Development Team",
      license: "MIT"
    };

    this.writeFile('package.json', JSON.stringify(rootPackageJson, null, 2));

    // ÂâçÁ´Ø package.json
    const frontendPackageJson = {
      name: `${this.projectName}-frontend`,
      version: "1.0.0",
      type: "module",
      scripts: {
        dev: "vite",
        build: "tsc && vite build",
        preview: "vite preview",
        lint: "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "lint:fix": "eslint . --ext ts,tsx --fix",
        "type-check": "tsc --noEmit",
        test: "jest",
        deploy: "wrangler pages deploy dist"
      },
      dependencies: {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.8.0",
        "antd": "^5.12.0",
        "zustand": "^4.4.0",
        "axios": "^1.6.0",
        "humps": "^2.0.1"
      },
      devDependencies: {
        "@types/react": "^18.2.0",
        "@types/react-dom": "^18.2.0",
        "@typescript-eslint/eslint-plugin": "^6.0.0",
        "@typescript-eslint/parser": "^6.0.0",
        "@vitejs/plugin-react": "^4.0.0",
        "eslint": "^8.45.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.0",
        "typescript": "^5.0.2",
        "vite": "^4.4.5",
        "wrangler": "^3.0.0"
      }
    };

    this.writeFile('frontend/package.json', JSON.stringify(frontendPackageJson, null, 2));

    // ÂêéÁ´Ø package.json
    const backendPackageJson = {
      name: `${this.projectName}-backend`,
      version: "1.0.0",
      type: "module",
      scripts: {
        dev: "wrangler dev",
        build: "tsc",
        deploy: "wrangler deploy",
        test: "jest",
        lint: "eslint . --ext ts --report-unused-disable-directives --max-warnings 0",
        "lint:fix": "eslint . --ext ts --fix",
        "type-check": "tsc --noEmit",
        "ai:test": "node scripts/test-ai-models.js",
        "ai:config": "node scripts/setup-ai-gateway.js"
      },
      dependencies: {
        "hono": "^3.11.0",
        "zod": "^3.22.0",
        "humps": "^2.0.1"
      },
      devDependencies: {
        "@cloudflare/workers-types": "^4.20231025.0",
        "@types/jest": "^29.5.0",
        "@typescript-eslint/eslint-plugin": "^6.0.0",
        "@typescript-eslint/parser": "^6.0.0",
        "eslint": "^8.45.0",
        "jest": "^29.5.0",
        "typescript": "^5.0.2",
        "wrangler": "^3.0.0"
      }
    };

    this.writeFile('backend/package.json', JSON.stringify(backendPackageJson, null, 2));

    // TypeScript ÈÖçÁΩÆ
    const tsConfig = {
      compilerOptions: {
        target: "ES2022",
        lib: ["ES2022"],
        module: "ESNext",
        moduleResolution: "bundler",
        strict: true,
        noImplicitAny: true,
        noImplicitReturns: true,
        noUnusedLocals: true,
        noUnusedParameters: true,
        skipLibCheck: true,
        allowSyntheticDefaultImports: true,
        forceConsistentCasingInFileNames: true,
        declaration: true,
        declarationMap: true,
        sourceMap: true
      }
    };

    this.writeFile('tsconfig.json', JSON.stringify(tsConfig, null, 2));
    this.writeFile('frontend/tsconfig.json', JSON.stringify({
      ...tsConfig,
      compilerOptions: {
        ...tsConfig.compilerOptions,
        target: "ES2020",
        lib: ["ES2020", "DOM", "DOM.Iterable"],
        allowImportingTsExtensions: true,
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: true,
        jsx: "react-jsx"
      },
      include: ["src"],
      references: [{ path: "./tsconfig.node.json" }]
    }, null, 2));

    this.writeFile('backend/tsconfig.json', JSON.stringify({
      ...tsConfig,
      compilerOptions: {
        ...tsConfig.compilerOptions,
        types: ["@cloudflare/workers-types"]
      },
      include: ["src/**/*"]
    }, null, 2));

    // Wrangler ÈÖçÁΩÆ
    const backendWrangler = `name = "${this.projectName}-backend"
main = "src/worker.ts"
compatibility_date = "2024-09-23"
compatibility_flags = ["nodejs_compat"]

# AI ÈÖçÁΩÆ
[ai]
binding = "AI"

[vars]
ENVIRONMENT = "production"
JWT_SECRET = "your-jwt-secret-change-in-production"
CORS_ORIGIN = "*"
AI_GATEWAY_ENABLED = "true"
AI_CACHE_TTL = "3600"
AI_RATE_LIMIT_PER_MINUTE = "100"
AI_COST_BUDGET_DAILY = "1.0"

[[d1_databases]]
binding = "DB"
database_name = "${this.projectName}-db"
database_id = "your-database-id"

[[kv_namespaces]]
binding = "CACHE_KV"
id = "your-kv-namespace-id"
preview_id = "your-preview-kv-namespace-id"

[[analytics_engine_datasets]]
binding = "ANALYTICS"

[env.development]
name = "${this.projectName}-backend-dev"
[env.development.vars]
ENVIRONMENT = "development"
AI_GATEWAY_ENABLED = "false"
`;

    this.writeFile('backend/wrangler.toml', backendWrangler);

    const frontendWrangler = `name = "${this.projectName}-frontend"
compatibility_date = "2024-01-01"

[build]
command = "npm run build"
cwd = "."
watch_dir = "src"

[build.upload]
format = "modules"
dir = "dist"
main = "./dist/index.html"

[vars]
VITE_APP_ENV = "production"
VITE_APP_TITLE = "${this.projectName}"
VITE_API_BASE_URL = "https://${this.projectName}-backend.workers.dev/api"
`;

    this.writeFile('frontend/wrangler.toml', frontendWrangler);
  }

  generateCodeTemplates() {
    console.log('üíª ÁîüÊàê‰ª£Á†ÅÊ®°Êùø...');

    // ÂêéÁ´ØÂÖ•Âè£Êñá‰ª∂
    const workerTs = `import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { authMiddleware } from './middleware/auth';
import { errorHandler } from './middleware/error';
import userRoutes from './routes/users';

export interface Env {
  DB: D1Database;
  JWT_SECRET: string;
  CORS_ORIGIN: string;
}

const app = new Hono<{ Bindings: Env }>();

// ‰∏≠Èó¥‰ª∂
app.use('*', logger());
app.use('*', cors({
  origin: (origin) => origin || '*',
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization'],
}));
app.use('*', errorHandler);

// ÂÅ•Â∫∑Ê£ÄÊü•
app.get('/health', (c) => {
  return c.json({
    success: true,
    message: 'Service is healthy',
    timestamp: new Date().toISOString()
  });
});

// API Ë∑ØÁî±
app.route('/api/users', userRoutes);

export default app;
`;

    this.writeFile('backend/src/worker.ts', workerTs);

    // ËÆ§ËØÅ‰∏≠Èó¥‰ª∂
    const authMiddleware = `import { Context, Next } from 'hono';
import { verify } from 'hono/jwt';
import { Env } from '../worker';

export const authMiddleware = async (c: Context<{ Bindings: Env }>, next: Next) => {
  const token = c.req.header('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return c.json({ error: 'Missing authorization token' }, 401);
  }

  try {
    const payload = await verify(token, c.env.JWT_SECRET);
    c.set('user', payload);
    await next();
  } catch (error) {
    return c.json({ error: 'Invalid token' }, 401);
  }
};

export const requireRole = (role: string) => {
  return async (c: Context, next: Next) => {
    const user = c.get('user') as any;
    if (user.role !== role) {
      return c.json({ error: 'Insufficient permissions' }, 403);
    }
    await next();
  };
};
`;

    this.writeFile('backend/src/middleware/auth.ts', authMiddleware);

    // ÈîôËØØÂ§ÑÁêÜ‰∏≠Èó¥‰ª∂
    const errorMiddleware = `import { Context, Next } from 'hono';

export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public code: string = 'INTERNAL_ERROR'
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export const errorHandler = async (c: Context, next: Next) => {
  try {
    await next();
  } catch (error) {
    console.error('Error:', error);
    
    if (error instanceof AppError) {
      return c.json({
        success: false,
        message: error.message,
        error: { code: error.code },
        timestamp: new Date().toISOString()
      }, error.statusCode);
    }
    
    return c.json({
      success: false,
      message: 'Internal server error',
      timestamp: new Date().toISOString()
    }, 500);
  }
};
`;

    this.writeFile('backend/src/middleware/error.ts', errorMiddleware);

    // Áî®Êà∑Ë∑ØÁî±Á§∫‰æã
    const userRoutes = `import { Hono } from 'hono';
import { authMiddleware, requireRole } from '../middleware/auth';
import { Env } from '../worker';

const users = new Hono<{ Bindings: Env }>();

// Ëé∑ÂèñÁî®Êà∑ÂàóË°®
users.get('/', authMiddleware, requireRole('admin'), async (c) => {
  try {
    const { results } = await c.env.DB.prepare(
      'SELECT id, email, role, created_at FROM users WHERE is_active = 1'
    ).all();

    return c.json({
      success: true,
      data: results,
      message: 'Ëé∑ÂèñÁî®Êà∑ÂàóË°®ÊàêÂäü',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return c.json({
      success: false,
      message: 'Ëé∑ÂèñÁî®Êà∑ÂàóË°®Â§±Ë¥•',
      timestamp: new Date().toISOString()
    }, 500);
  }
});

// Ëé∑ÂèñÁî®Êà∑ËØ¶ÊÉÖ
users.get('/:id', authMiddleware, async (c) => {
  const id = c.req.param('id');
  
  try {
    const { results } = await c.env.DB.prepare(
      'SELECT id, email, role, created_at FROM users WHERE id = ? AND is_active = 1'
    ).bind(id).all();

    if (results.length === 0) {
      return c.json({
        success: false,
        message: 'Áî®Êà∑‰∏çÂ≠òÂú®',
        timestamp: new Date().toISOString()
      }, 404);
    }

    return c.json({
      success: true,
      data: results[0],
      message: 'Ëé∑ÂèñÁî®Êà∑ËØ¶ÊÉÖÊàêÂäü',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return c.json({
      success: false,
      message: 'Ëé∑ÂèñÁî®Êà∑ËØ¶ÊÉÖÂ§±Ë¥•',
      timestamp: new Date().toISOString()
    }, 500);
  }
});

export default users;
`;

    this.writeFile('backend/src/routes/users.ts', userRoutes);

    // AI ÈÖçÁΩÆÊñá‰ª∂
    const aiConfig = `// AI Ê®°ÂûãÈÖçÁΩÆ
export const AI_MODEL_CONFIG = {
  // ÂÜÖÂÆπÂÆâÂÖ®Ê£ÄÊµã (‰∏ªË¶Å)
  contentSafety: {
    primary: '@cf/meta/llama-guard-3-8b',
    fallback: '@cf/meta/llama-3.1-8b-instruct',
    timeout: 5000,
    confidenceThreshold: 0.7
  },

  // ÊñáÊú¨ÂàÜÁ±ª (Âø´ÈÄü)
  textClassification: {
    primary: '@cf/huggingface/distilbert-sst-2-int8',
    timeout: 2000,
    confidenceThreshold: 0.8
  },

  // ÊÉÖÊÑüÂàÜÊûê (Ê∑±Â∫¶)
  sentimentAnalysis: {
    primary: '@cf/meta/llama-3-8b-instruct',
    timeout: 3000,
    confidenceThreshold: 0.6
  },

  // ËØ≠‰πâÂàÜÊûê (ÂµåÂÖ•)
  semanticAnalysis: {
    primary: '@cf/baai/bge-base-en-v1.5',
    timeout: 2000,
    confidenceThreshold: 0.7
  }
};

export interface ModelStatus {
  model: string;
  available: boolean;
  responseTime: number;
  error: string | null;
}

// Êô∫ËÉΩÊ®°ÂûãÊ£ÄÊµã
export async function detectAvailableModels(ai: Ai): Promise<ModelStatus[]> {
  const models = Object.values(AI_MODEL_CONFIG);
  const results = await Promise.allSettled(
    models.map(async (config) => {
      const start = Date.now();
      try {
        await ai.run(config.primary, { text: "test" });
        return {
          model: config.primary,
          available: true,
          responseTime: Date.now() - start,
          error: null
        };
      } catch (error) {
        return {
          model: config.primary,
          available: false,
          responseTime: Date.now() - start,
          error: error.message
        };
      }
    })
  );

  return results.map(result =>
    result.status === 'fulfilled' ? result.value : result.reason
  );
}
`;

    this.writeFile('backend/src/config/aiConfig.ts', aiConfig);

    // AI ÂÜÖÂÆπÂÆ°Ê†∏ÊúçÂä°
    const aiModerationService = `import { AI_MODEL_CONFIG } from '../config/aiConfig';

export interface ModerationResult {
  action: 'approve' | 'review' | 'reject';
  reason: string;
  confidence: number;
  details: any;
}

export interface AIResult {
  riskScore: number;
  recommendation: string;
  details: any;
  confidence: number;
}

export class HybridModerationService {
  async moderateContent(
    content: string,
    contentType: 'story' | 'questionnaire' | 'comment',
    ai: Ai
  ): Promise<ModerationResult> {
    try {
      // AI ÂÆ°Ê†∏
      const aiResult = await this.aiBasedModeration(content, ai);

      // Âü∫‰∫éÈ£éÈô©ËØÑÂàÜÂÜ≥Á≠ñ
      if (aiResult.riskScore > 0.8) {
        return {
          action: 'reject',
          reason: 'ai_high_risk',
          confidence: aiResult.confidence,
          details: aiResult
        };
      } else if (aiResult.riskScore > 0.5) {
        return {
          action: 'review',
          reason: 'ai_medium_risk',
          confidence: aiResult.confidence,
          details: aiResult
        };
      }

      return {
        action: 'approve',
        reason: 'low_risk',
        confidence: aiResult.confidence,
        details: aiResult
      };
    } catch (error) {
      // AI ÊúçÂä°‰∏çÂèØÁî®Êó∂ÁöÑÈôçÁ∫ßÂ§ÑÁêÜ
      return {
        action: 'review',
        reason: 'ai_service_unavailable',
        confidence: 0.5,
        details: { error: error.message }
      };
    }
  }

  private async aiBasedModeration(content: string, ai: Ai): Promise<AIResult> {
    // ÂÜÖÂÆπÂÆâÂÖ®Ê£ÄÊµã
    const safetyResult = await ai.run(AI_MODEL_CONFIG.contentSafety.primary, {
      messages: [{ role: "user", content }]
    });

    // ÊÉÖÊÑüÂàÜÊûê
    const sentimentResult = await ai.run(AI_MODEL_CONFIG.sentimentAnalysis.primary, {
      messages: [
        {
          role: "system",
          content: "ÂàÜÊûêÂÜÖÂÆπÁöÑÊÉÖÊÑüÂÄæÂêëÂíåÈ£éÈô©Á≠âÁ∫ßÔºåËøîÂõû0-1ÁöÑÈ£éÈô©ÂàÜÊï∞"
        },
        { role: "user", content }
      ]
    });

    // ËÆ°ÁÆóÁªºÂêàÈ£éÈô©ËØÑÂàÜ
    const riskScore = this.calculateRiskScore(safetyResult, sentimentResult);

    return {
      riskScore,
      recommendation: this.getRecommendation(riskScore),
      details: { safety: safetyResult, sentiment: sentimentResult },
      confidence: 0.8
    };
  }

  private calculateRiskScore(safetyResult: any, sentimentResult: any): number {
    // ÁÆÄÂåñÁöÑÈ£éÈô©ËØÑÂàÜÁÆóÊ≥ï
    let score = 0;

    // ÂÆâÂÖ®Ê£ÄÊµãÊùÉÈáç 60%
    if (safetyResult?.response?.includes('unsafe')) {
      score += 0.6;
    }

    // ÊÉÖÊÑüÂàÜÊûêÊùÉÈáç 40%
    if (sentimentResult?.response?.includes('negative')) {
      score += 0.4;
    }

    return Math.min(score, 1.0);
  }

  private getRecommendation(riskScore: number): string {
    if (riskScore > 0.8) return 'reject';
    if (riskScore > 0.5) return 'review';
    return 'approve';
  }
}
`;

    this.writeFile('backend/src/services/aiModerationService.ts', aiModerationService);

    // ÂâçÁ´Ø App ÁªÑ‰ª∂
    const appTsx = `import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { ConfigProvider } from 'antd';
import zhCN from 'antd/locale/zh_CN';
import HomePage from './pages/HomePage';
import './App.css';

function App() {
  return (
    <ConfigProvider locale={zhCN}>
      <Router>
        <div className="App">
          <Routes>
            <Route path="/" element={<HomePage />} />
          </Routes>
        </div>
      </Router>
    </ConfigProvider>
  );
}

export default App;
`;

    this.writeFile('frontend/src/App.tsx', appTsx);

    // ÂâçÁ´Ø‰∏ªÈ°µÁªÑ‰ª∂
    const homePageTsx = `import React, { useEffect, useState } from 'react';
import { Card, Button, Typography, Space } from 'antd';
import { apiClient } from '../services/apiClient';

const { Title, Paragraph } = Typography;

interface User {
  id: string;
  email: string;
  role: string;
  createdAt: string;
}

const HomePage: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);

  const fetchUsers = async () => {
    setLoading(true);
    try {
      const response = await apiClient.get('/users');
      if (response.data.success) {
        setUsers(response.data.data);
      }
    } catch (error) {
      console.error('Failed to fetch users:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchUsers();
  }, []);

  return (
    <div style={{ padding: '24px' }}>
      <Card>
        <Space direction="vertical" size="large" style={{ width: '100%' }}>
          <div>
            <Title level={2}>Ê¨¢Ëøé‰ΩøÁî® ${this.projectName}</Title>
            <Paragraph>
              ËøôÊòØ‰∏Ä‰∏™Âü∫‰∫é Cloudflare Âπ≥Âè∞ÁöÑÁé∞‰ª£Âåñ Web Â∫îÁî®Á®ãÂ∫è„ÄÇ
            </Paragraph>
          </div>
          
          <div>
            <Button type="primary" onClick={fetchUsers} loading={loading}>
              Âà∑Êñ∞Áî®Êà∑ÂàóË°®
            </Button>
          </div>
          
          <div>
            <Title level={3}>Áî®Êà∑ÂàóË°® ({users.length})</Title>
            {users.map(user => (
              <Card key={user.id} size="small" style={{ marginBottom: 8 }}>
                <p><strong>ÈÇÆÁÆ±:</strong> {user.email}</p>
                <p><strong>ËßíËâ≤:</strong> {user.role}</p>
                <p><strong>ÂàõÂª∫Êó∂Èó¥:</strong> {user.createdAt}</p>
              </Card>
            ))}
          </div>
        </Space>
      </Card>
    </div>
  );
};

export default HomePage;
`;

    this.writeFile('frontend/src/pages/HomePage.tsx', homePageTsx);

    // API ÂÆ¢Êà∑Á´Ø
    const apiClientTs = `import axios from 'axios';
import humps from 'humps';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8787/api';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// ËØ∑Ê±ÇÊã¶Êà™Âô® - camelCase ËΩ¨ snake_case
apiClient.interceptors.request.use(
  (config) => {
    if (config.data) {
      config.data = humps.decamelizeKeys(config.data);
    }
    if (config.params) {
      config.params = humps.decamelizeKeys(config.params);
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// ÂìçÂ∫îÊã¶Êà™Âô® - snake_case ËΩ¨ camelCase
apiClient.interceptors.response.use(
  (response) => {
    if (response.data) {
      response.data = humps.camelizeKeys(response.data);
    }
    return response;
  },
  (error) => {
    if (error.response?.data) {
      error.response.data = humps.camelizeKeys(error.response.data);
    }
    return Promise.reject(error);
  }
);

export default apiClient;
`;

    this.writeFile('frontend/src/services/apiClient.ts', apiClientTs);

    // VSCode ÈÖçÁΩÆ
    const vscodeSettings = `{
  "augment.enabled": true,
  "augment.codeCompletion": {
    "enabled": true,
    "triggerCharacters": [".", "(", "[", "{"],
    "maxSuggestions": 5,
    "contextLines": 50
  },
  "augment.codeReview": {
    "enabled": true,
    "autoReview": false,
    "reviewOnSave": true,
    "focusAreas": [
      "security",
      "performance",
      "naming_conventions",
      "error_handling"
    ]
  },
  "augment.documentation": {
    "autoGenerate": true,
    "includeExamples": true,
    "language": "zh-CN"
  },
  "typescript.preferences.importModuleSpecifier": "relative",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "files.associations": {
    "*.toml": "toml"
  }
}`;

    this.writeFile('.vscode/settings.json', vscodeSettings);

    const vscodeExtensions = `{
  "recommendations": [
    "augmentcode.augment",
    "ms-vscode.vscode-typescript-next",
    "esbenp.prettier-vscode",
    "dbaeumer.vscode-eslint",
    "bradlc.vscode-tailwindcss",
    "cloudflare.vscode-cloudflare-workers",
    "rangav.vscode-thunder-client"
  ]
}`;

    this.writeFile('.vscode/extensions.json', vscodeExtensions);
  }

  generateDocumentation() {
    console.log('üìö ÁîüÊàêÊñáÊ°£...');

    const readme = `# ${this.projectName}

Âü∫‰∫é Cloudflare Âπ≥Âè∞ÁöÑÁé∞‰ª£Âåñ Web Â∫îÁî®Á®ãÂ∫è

## üöÄ Âø´ÈÄüÂºÄÂßã

### ÁéØÂ¢ÉË¶ÅÊ±Ç

- Node.js >= 18.0.0
- pnpm >= 8.0.0
- Cloudflare Ë¥¶Âè∑

### ÂÆâË£Ö‰æùËµñ

\`\`\`bash
pnpm install
\`\`\`

### ÂºÄÂèëÁéØÂ¢É

\`\`\`bash
# ÂêØÂä®ÂÆåÊï¥ÂºÄÂèëÁéØÂ¢É
pnpm dev

# ÂçïÁã¨ÂêØÂä®ÂâçÁ´Ø
pnpm dev:frontend

# ÂçïÁã¨ÂêØÂä®ÂêéÁ´Ø
pnpm dev:backend
\`\`\`

### ÊûÑÂª∫ÈÉ®ÁΩ≤

\`\`\`bash
# ÊûÑÂª∫È°πÁõÆ
pnpm build

# ÈÉ®ÁΩ≤Âà∞ Cloudflare
pnpm deploy
\`\`\`

## üìÅ È°πÁõÆÁªìÊûÑ

\`\`\`
${this.projectName}/
‚îú‚îÄ‚îÄ frontend/           # React ÂâçÁ´Ø (Cloudflare Pages)
‚îú‚îÄ‚îÄ backend/            # Hono ÂêéÁ´Ø (Cloudflare Workers)
‚îú‚îÄ‚îÄ database/           # D1 Êï∞ÊçÆÂ∫ì
‚îú‚îÄ‚îÄ docs/              # È°πÁõÆÊñáÊ°£
‚îî‚îÄ‚îÄ scripts/           # Â∑•ÂÖ∑ËÑöÊú¨
\`\`\`

## üõ†Ô∏è ÊäÄÊúØÊ†à

- **ÂâçÁ´Ø**: React 18 + TypeScript + Vite + Ant Design
- **ÂêéÁ´Ø**: Cloudflare Workers + Hono.js + TypeScript
- **Êï∞ÊçÆÂ∫ì**: Cloudflare D1 (SQLite)
- **AIÊúçÂä°**: Cloudflare Workers AI + AI Gateway
- **ÁºìÂ≠ò**: Cloudflare KV
- **ÂàÜÊûê**: Cloudflare Analytics Engine
- **ÈÉ®ÁΩ≤**: Cloudflare Pages + Workers
- **ÂºÄÂèëÂ∑•ÂÖ∑**: VSCode + Augment AI Assistant

## üìñ ÂºÄÂèëËßÑËåÉ

ËØ∑ÂèÇËÄÉ [Cloudflare ÂºÄÂèëËßÑËåÉÊåáÂçó](./docs/DEVELOPMENT_STANDARDS.md)

## ü§ñ AI ÂäüËÉΩ

### AI Ê®°ÂûãÈÖçÁΩÆ
È°πÁõÆÈõÜÊàê‰∫Ü Cloudflare Workers AIÔºåÊîØÊåÅÔºö
- **ÂÜÖÂÆπÂÆâÂÖ®Ê£ÄÊµã**: Ëá™Âä®ËØÜÂà´‰∏çÂΩìÂÜÖÂÆπ
- **ÊÉÖÊÑüÂàÜÊûê**: ÂàÜÊûêÁî®Êà∑ÊÉÖÊÑüÂÄæÂêë
- **ÊñáÊú¨ÂàÜÁ±ª**: Êô∫ËÉΩÂÜÖÂÆπÂàÜÁ±ª
- **ËØ≠‰πâÂàÜÊûê**: Ê∑±Â∫¶ËØ≠‰πâÁêÜËß£

### AI ÂºÄÂèëÂä©Êâã
Êé®Ëçê‰ΩøÁî® VSCode + Augment ËøõË°å AI ËæÖÂä©ÂºÄÂèëÔºö
- Êô∫ËÉΩ‰ª£Á†ÅË°•ÂÖ®
- Ëá™Âä®‰ª£Á†ÅÂÆ°Êü•
- ÊñáÊ°£ÁîüÊàê
- ÈîôËØØÊ£ÄÊµãÂíå‰øÆÂ§ç

### ÊµãËØï AI ÂäüËÉΩ
\`\`\`bash
# ÊµãËØï AI Ê®°ÂûãÂèØÁî®ÊÄß
npm run ai:test

# ÈÖçÁΩÆ AI Gateway
npm run ai:config
\`\`\`

## üîß ÈÖçÁΩÆ

### ÁéØÂ¢ÉÂèòÈáè

ÂêéÁ´ØÁéØÂ¢ÉÂèòÈáèÂú® \`backend/wrangler.toml\` ‰∏≠ÈÖçÁΩÆÔºö

\`\`\`toml
[vars]
JWT_SECRET = "your-jwt-secret"
CORS_ORIGIN = "*"
\`\`\`

ÂâçÁ´ØÁéØÂ¢ÉÂèòÈáèÂú® \`frontend/wrangler.toml\` ‰∏≠ÈÖçÁΩÆÔºö

\`\`\`toml
[vars]
VITE_API_BASE_URL = "https://your-backend.workers.dev/api"
\`\`\`

### Êï∞ÊçÆÂ∫ì

1. ÂàõÂª∫ D1 Êï∞ÊçÆÂ∫ìÔºö
\`\`\`bash
wrangler d1 create ${this.projectName}-db
\`\`\`

2. Êõ¥Êñ∞ \`backend/wrangler.toml\` ‰∏≠ÁöÑÊï∞ÊçÆÂ∫ì ID

3. ËøêË°åËøÅÁßªÔºö
\`\`\`bash
wrangler d1 execute ${this.projectName}-db --file=database/migrations/001_create_users.sql
\`\`\`

## üöÄ ÈÉ®ÁΩ≤

### ÂêéÁ´ØÈÉ®ÁΩ≤

\`\`\`bash
cd backend
wrangler deploy
\`\`\`

### ÂâçÁ´ØÈÉ®ÁΩ≤

\`\`\`bash
cd frontend
npm run build
wrangler pages deploy dist
\`\`\`

## üìù ËÆ∏ÂèØËØÅ

MIT License
`;

    this.writeFile('README.md', readme);

    // Êï∞ÊçÆÂ∫ìËøÅÁßªÁ§∫‰æã
    const migration = `-- Migration: Create users table
-- Created: ${new Date().toISOString()}

CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  role TEXT DEFAULT 'user',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  is_active INTEGER DEFAULT 1,
  is_test_data INTEGER DEFAULT 0
);

-- ÂàõÂª∫Á¥¢Âºï
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);
CREATE INDEX IF NOT EXISTS idx_users_active ON users(is_active);
CREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at);

-- ÊèíÂÖ•ÁÆ°ÁêÜÂëòÁî®Êà∑
INSERT OR IGNORE INTO users (id, email, password_hash, role) 
VALUES ('admin-001', 'admin@example.com', 'hashed-password', 'admin');
`;

    this.writeFile('database/migrations/001_create_users.sql', migration);

    // AI ÊµãËØïËÑöÊú¨
    const aiTestScript = `#!/usr/bin/env node

/**
 * AI Ê®°ÂûãÊµãËØïËÑöÊú¨
 * ÊµãËØï Cloudflare Workers AI Ê®°ÂûãÁöÑÂèØÁî®ÊÄßÂíåÊÄßËÉΩ
 */

const testModels = [
  '@cf/meta/llama-guard-3-8b',
  '@cf/huggingface/distilbert-sst-2-int8',
  '@cf/meta/llama-3-8b-instruct',
  '@cf/baai/bge-base-en-v1.5',
  '@cf/meta/llama-3.1-8b-instruct'
];

async function testAIModels() {
  console.log('ü§ñ ÂºÄÂßãÊµãËØï AI Ê®°Âûã...');

  const testContent = "ËøôÊòØ‰∏Ä‰∏™ÊµãËØïÂÜÖÂÆπÔºåÁî®‰∫éÈ™åËØÅAIÊ®°ÂûãÁöÑÂèØÁî®ÊÄß„ÄÇ";

  for (const model of testModels) {
    console.log(\`\\nüìä ÊµãËØïÊ®°Âûã: \${model}\`);

    try {
      const start = Date.now();

      // ËøôÈáåÈúÄË¶ÅÂÆûÈôÖÁöÑ Cloudflare Workers AI Ë∞ÉÁî®
      // Âú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠ÔºåÈúÄË¶ÅÈÖçÁΩÆÊ≠£Á°ÆÁöÑËÆ§ËØÅ‰ø°ÊÅØ
      console.log('‚ö†Ô∏è  ËØ∑Âú® Cloudflare Workers ÁéØÂ¢É‰∏≠ËøêË°åÊ≠§ÊµãËØï');
      console.log('   ÊàñÈÖçÁΩÆ Cloudflare API ËÆ§ËØÅ‰ø°ÊÅØ');

      const responseTime = Date.now() - start;
      console.log(\`‚úÖ Ê®°ÂûãÂèØÁî®ÔºåÂìçÂ∫îÊó∂Èó¥: \${responseTime}ms\`);

    } catch (error) {
      console.log(\`‚ùå Ê®°Âûã‰∏çÂèØÁî®: \${error.message}\`);
    }
  }

  console.log('\\nüéâ AI Ê®°ÂûãÊµãËØïÂÆåÊàêÔºÅ');
}

if (require.main === module) {
  testAIModels().catch(console.error);
}

module.exports = { testAIModels };
`;

    this.writeFile('scripts/test-ai-models.js', aiTestScript);

    // AI Gateway ËÆæÁΩÆËÑöÊú¨
    const aiGatewaySetup = `#!/usr/bin/env node

/**
 * AI Gateway ËÆæÁΩÆËÑöÊú¨
 * Â∏ÆÂä©ÈÖçÁΩÆ Cloudflare AI Gateway
 */

console.log('üöÄ AI Gateway ËÆæÁΩÆÂêëÂØº');
console.log('');
console.log('ËØ∑ÊåâÁÖß‰ª•‰∏ãÊ≠•È™§ÈÖçÁΩÆ AI Gateway:');
console.log('');
console.log('1. ËÆøÈóÆ Cloudflare Dashboard:');
console.log('   https://dash.cloudflare.com/[account-id]/ai/ai-gateway');
console.log('');
console.log('2. ÁÇπÂáª "Create Gateway" ÊåâÈíÆ');
console.log('');
console.log('3. ÈÖçÁΩÆ Gateway ËÆæÁΩÆ:');
console.log('   - Gateway Name: \${process.env.PROJECT_NAME || "my-project"}-ai-gateway');
console.log('   - Description: AI content moderation for employment survey platform');
console.log('');
console.log('4. Ëé∑Âèñ Gateway ÈÖçÁΩÆÂêéÔºåÊõ¥Êñ∞ wrangler.toml:');
console.log('   [ai]');
console.log('   binding = "AI"');
console.log('   gateway_id = "your-gateway-id"');
console.log('');
console.log('5. ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáè:');
console.log('   wrangler secret put AI_GATEWAY_TOKEN');
console.log('');
console.log('6. ÊµãËØï AI ÂäüËÉΩ:');
console.log('   npm run ai:test');
console.log('');
console.log('üìñ Êõ¥Â§ö‰ø°ÊÅØËØ∑ÂèÇËÄÉ: docs/AI_SETUP_GUIDE.md');
`;

    this.writeFile('scripts/setup-ai-gateway.js', aiGatewaySetup);
  }

  initializeGit() {
    console.log('üì¶ ÂàùÂßãÂåñ Git ‰ªìÂ∫ì...');

    const gitignore = `# Dependencies
node_modules/
.pnpm-store/

# Build outputs
dist/
build/

# Environment files
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Cloudflare
.wrangler/
wrangler.toml.bak

# Testing
coverage/
.nyc_output/

# Temporary files
*.tmp
*.temp
`;

    this.writeFile('.gitignore', gitignore);

    try {
      process.chdir(this.projectPath);
      execSync('git init', { stdio: 'inherit' });
      execSync('git add .', { stdio: 'inherit' });
      execSync('git commit -m "feat: ÂàùÂßãÂåñÈ°πÁõÆ\n\n- Âü∫‰∫é Cloudflare ÂºÄÂèëËßÑËåÉÂàõÂª∫\n- ÂåÖÂê´ÂâçÂêéÁ´ØÂü∫Á°ÄÊû∂ÊûÑ\n- ÈÖçÁΩÆÂºÄÂèëÁéØÂ¢É"', { stdio: 'inherit' });
    } catch (error) {
      console.warn('‚ö†Ô∏è Git ÂàùÂßãÂåñÂ§±Ë¥•ÔºåËØ∑ÊâãÂä®ÂàùÂßãÂåñ');
    }
  }

  writeFile(relativePath, content) {
    const fullPath = path.join(this.projectPath, relativePath);
    const dir = path.dirname(fullPath);
    
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    fs.writeFileSync(fullPath, content);
  }
}

// ÂëΩ‰ª§Ë°åÊé•Âè£
const projectName = process.argv[2];

if (!projectName) {
  console.error('‚ùå ËØ∑Êèê‰æõÈ°πÁõÆÂêçÁß∞');
  console.log('‰ΩøÁî®ÊñπÊ≥ï: node cloudflare-project-generator.js <project-name>');
  process.exit(1);
}

if (fs.existsSync(projectName)) {
  console.error(`‚ùå ÁõÆÂΩï ${projectName} Â∑≤Â≠òÂú®`);
  process.exit(1);
}

const generator = new CloudflareProjectGenerator(projectName);
generator.generate().catch(error => {
  console.error('‚ùå È°πÁõÆÁîüÊàêÂ§±Ë¥•:', error);
  process.exit(1);
});
